// Q1
// Encapsulation : Collect data and function within a single class and control who sees it without using access modifiers
// Abstractio : Hide unimportant or complex details and highlight the essential need for the service using access modifiers
// Inheritance : I created two classes, one inherits the function from the other to benefit from reusability
// Polymorphism : The function has more than one use or more than one use

// -------------------------------------------------------------------------

// Q2
// Public: Anyone can reach it
// Private: No one can reach it except inside the class
// Protect: Like private, but if there is an inheritance, it can still reach you
// ------------------------------------------

// Q3
// ---------
// #include <iostream>
// #include <exception>
// using namespace std;

// class DivisionByZeroException : public exception {
// public:
//     const char* what() const noexcept override {
//         return "Error: Division by zero is not allowed!";
//     }
// };

// class NegativeDivisionException : public exception {
// public:
//     const char* what() const noexcept override {
//         return "Error: Division by a negative number is not allowed!";
//     }
// };

// int divide(int x, int y) {
//     if (y == 0) {
//         throw DivisionByZeroException();
//     }
//     if (y < 0) {
//         throw NegativeDivisionException();
//     }
//     return x / y;
// }

// int main() {
//     try {
//         int a, b;
//         cout << "Enter two integers (x y): ";
//         cin >> a >> b;

//         int result = divide(a, b);
//         cout << "Result: " << result << endl;
//     }
//     catch (DivisionByZeroException& e) {
//         cout << e.what() << endl;
//     }
//     catch (NegativeDivisionException& e) {
//         cout << e.what() << endl;
//     }
//     catch (...) {
//         cout << "Unknown error occurred!" << endl;
//     }

//     return 0;
// }
//--------------------------------------

// Q4
// ----------------
// #include <iostream>
// using namespace std;

// template <typename T>
// class Calculator {
// public:
//     static T add(T a, T b) {
//         return a + b;
//     }

//     static T subtract(T a, T b) {
//         return a - b;
//     }

//     static T multiply(T a, T b) {
//         return a * b;
//     }

//     static T divide(T a, T b) {
//         if (b != 0)
//             return a / b;
//         else {
//             cout << "Error: Division by zero!" << endl;
//             return 0;
//         }
//     }
// };

// int main() {
//     cout << "Addition: " << Calculator<int>::add(10, 5) << endl;
//     cout << "Subtraction: " << Calculator<int>::subtract(10, 5) << endl;
//     cout << "Multiplication: " << Calculator<int>::multiply(10, 5) << endl;
//     cout << "Division: " << Calculator<int>::divide(10, 5) << endl;

//     cout << "\nWith float:" << endl;
//     cout << "Addition: " << Calculator<float>::add(10.5, 5.2) << endl;
//     cout << "Subtraction: " << Calculator<float>::subtract(10.5, 5.2) << endl;
//     cout << "Multiplication: " << Calculator<float>::multiply(10.5, 5.2) << endl;
//     cout << "Division: " << Calculator<float>::divide(10.5, 5.2) << endl;

//     return 0;
// }
 //-------------------------------------------------------------------
 
//  Q5
//  Overloading : The same function, but with different parameters in number and type, determined at COMPILE time
//  override : Same function and parameter, and I use the VIRTUAL function to replace it from the parent class
//-------------------------------------------------------------------------------------
Q6
--------------
#include<iostream>
using namespace std;
class Point2d{
    private:
    float x = 0.0, y =0.0;
    public:
    Point2d(float x1, float y1) : x(x1), y(y1) {}
    Point2d(){}
    void setX(float x1) { 
        x = x1; 
    }
    void setY(float y1) { 
        y = y1; 
    }
    float getX() const { 
        return x; 
    }
    float getY() const { 
        return y; 
    }
    void setxy(float x1, float y1) { 
        x = x1; 
        y = y1; 
    }
    float *getxy(){
        static float xy[2];
        xy[0] = x;
        xy[1] = y;
        return xy; 
    }
};

class Point3d : public Point2d {
    private:
    float z = 0.0;
    public:
    Point3d(float x1, float y1, float z1) : Point2d(x1, y1), z(z1) {}
    Point3d() : Point2d() {}
    void setZ(float z1) { 
        z = z1; 
    }
    float getZ() const { 
        return z; 
    }
    void setxyz(float x1, float y1, float z1) { 
        setxy(x1, y1); 
        z = z1; 
    }
    float *getxyz(){
        static float xyz[3];
        xyz[0] = getX();
        xyz[1] = getY();
        xyz[2] = z;
        return xyz; 
    }
};


